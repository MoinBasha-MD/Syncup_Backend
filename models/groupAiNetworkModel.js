const mongoose = require('mongoose');

// Group AI Network Model - Handles group AI communications and coordination
const groupAiNetworkSchema = new mongoose.Schema({
  // Unique network identifier
  networkId: {
    type: String,
    required: true,
    unique: true,
    default: () => `network_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  },
  
  // Reference to the group this network serves
  groupId: {
    type: String,
    required: true,
    index: true
  },
  
  // AI that initiated this group communication
  coordinatorAiId: {
    type: String,
    required: true,
    index: true
  },
  
  // All participating AI instances
  memberAiIds: [{
    type: String,
    required: true
  }],
  
  // Network communication type
  networkType: {
    type: String,
    enum: ['broadcast', 'consensus', 'sequential'],
    default: 'broadcast',
    index: true
  },
  
  // Current network status
  status: {
    type: String,
    enum: ['active', 'completed', 'failed', 'timeout'],
    default: 'active',
    index: true
  },
  
  // Communication topic/purpose
  topic: {
    type: String,
    required: true,
    maxlength: 200
  },
  
  // Context and metadata
  context: {
    originalRequest: {
      type: String,
      required: true,
      maxlength: 1000
    },
    requestType: {
      type: String,
      enum: ['schedule', 'social', 'information', 'task', 'poll'],
      required: true
    },
    urgencyLevel: {
      type: Number,
      min: 1,
      max: 5,
      default: 3
    },
    expectedResponseTime: {
      type: Number, // in minutes
      default: 30
    },
    requiresConsensus: {
      type: Boolean,
      default: false
    },
    minimumResponses: {
      type: Number,
      default: 1
    }
  },
  
  // Individual AI responses
  responses: [{
    aiId: {
      type: String,
      required: true
    },
    userId: {
      type: String,
      required: true
    },
    response: {
      status: {
        type: String,
        enum: ['pending', 'responded', 'failed', 'timeout'],
        default: 'pending'
      },
      data: {
        available: Boolean,
        message: String,
        timeSlots: [String],
        preferences: mongoose.Schema.Types.Mixed,
        confidence: {
          type: Number,
          min: 0,
          max: 1,
          default: 1
        }
      },
      metadata: {
        responseTime: Number, // in seconds
        autoGenerated: {
          type: Boolean,
          default: false
        },
        requiresUserConfirmation: {
          type: Boolean,
          default: true
        }
      }
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    lastUpdated: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Network result and consensus
  result: {
    consensus: {
      achieved: {
        type: Boolean,
        default: false
      },
      percentage: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      },
      decision: String,
      agreedTimeSlots: [String],
      agreedLocation: String,
      participantCount: Number
    },
    finalDecision: {
      type: String,
      maxlength: 500
    },
    participationRate: {
      type: Number,
      min: 0,
      max: 1,
      default: 0
    },
    successfulResponses: {
      type: Number,
      default: 0
    },
    failedResponses: {
      type: Number,
      default: 0
    }
  },
  
  // Timing and lifecycle
  startedAt: {
    type: Date,
    default: Date.now
  },
  
  completedAt: {
    type: Date
  },
  
  timeoutAt: {
    type: Date,
    default: function() {
      // Default timeout: 1 hour from creation
      return new Date(Date.now() + 60 * 60 * 1000);
    }
  },
  
  // Configuration
  settings: {
    allowPartialConsensus: {
      type: Boolean,
      default: true
    },
    consensusThreshold: {
      type: Number,
      min: 0.1,
      max: 1.0,
      default: 0.6 // 60% agreement required
    },
    maxWaitTime: {
      type: Number,
      default: 3600 // seconds (1 hour)
    },
    retryFailedResponses: {
      type: Boolean,
      default: true
    }
  }
}, {
  timestamps: true
});

// Indexes for performance optimization
groupAiNetworkSchema.index({ groupId: 1, status: 1 });
groupAiNetworkSchema.index({ coordinatorAiId: 1, createdAt: -1 });
groupAiNetworkSchema.index({ status: 1, timeoutAt: 1 });
groupAiNetworkSchema.index({ 'responses.aiId': 1 });
groupAiNetworkSchema.index({ networkType: 1, status: 1 });

// Virtual for checking if network is expired
groupAiNetworkSchema.virtual('isExpired').get(function() {
  return this.timeoutAt < new Date();
});

// Virtual for checking completion percentage
groupAiNetworkSchema.virtual('completionPercentage').get(function() {
  const totalMembers = this.memberAiIds.length;
  const respondedMembers = this.responses.filter(r => r.response.status === 'responded').length;
  return totalMembers > 0 ? respondedMembers / totalMembers : 0;
});

// Instance methods
groupAiNetworkSchema.methods.addResponse = function(aiId, userId, responseData) {
  // Find existing response or create new one
  let existingResponse = this.responses.find(r => r.aiId === aiId);
  
  if (existingResponse) {
    existingResponse.response = responseData;
    existingResponse.lastUpdated = new Date();
  } else {
    this.responses.push({
      aiId,
      userId,
      response: responseData,
      timestamp: new Date(),
      lastUpdated: new Date()
    });
  }
  
  // Update participation rate
  this.result.participationRate = this.completionPercentage;
  
  return this.save();
};

groupAiNetworkSchema.methods.calculateConsensus = function() {
  const responses = this.responses.filter(r => r.response.status === 'responded');
  const totalResponses = responses.length;
  
  if (totalResponses === 0) {
    return { achieved: false, percentage: 0 };
  }
  
  // Simple consensus calculation based on availability
  const availableCount = responses.filter(r => r.response.data.available === true).length;
  const consensusPercentage = availableCount / totalResponses;
  
  const consensusAchieved = consensusPercentage >= this.settings.consensusThreshold;
  
  this.result.consensus = {
    achieved: consensusAchieved,
    percentage: consensusPercentage,
    participantCount: totalResponses
  };
  
  // Aggregate common time slots if available
  if (consensusAchieved) {
    const allTimeSlots = responses
      .filter(r => r.response.data.available && r.response.data.timeSlots)
      .flatMap(r => r.response.data.timeSlots);
    
    // Find common time slots (simple intersection)
    const timeSlotCounts = {};
    allTimeSlots.forEach(slot => {
      timeSlotCounts[slot] = (timeSlotCounts[slot] || 0) + 1;
    });
    
    const commonSlots = Object.entries(timeSlotCounts)
      .filter(([slot, count]) => count >= Math.ceil(totalResponses * this.settings.consensusThreshold))
      .map(([slot, count]) => slot);
    
    this.result.consensus.agreedTimeSlots = commonSlots;
  }
  
  return this.result.consensus;
};

groupAiNetworkSchema.methods.markCompleted = function(finalDecision) {
  this.status = 'completed';
  this.completedAt = new Date();
  this.result.finalDecision = finalDecision;
  
  // Calculate final statistics
  const respondedCount = this.responses.filter(r => r.response.status === 'responded').length;
  const failedCount = this.responses.filter(r => r.response.status === 'failed').length;
  
  this.result.successfulResponses = respondedCount;
  this.result.failedResponses = failedCount;
  this.result.participationRate = this.completionPercentage;
  
  return this.save();
};

groupAiNetworkSchema.methods.markFailed = function(reason) {
  this.status = 'failed';
  this.completedAt = new Date();
  this.result.finalDecision = `Failed: ${reason}`;
  return this.save();
};

groupAiNetworkSchema.methods.markTimeout = function() {
  this.status = 'timeout';
  this.completedAt = new Date();
  
  // Mark pending responses as timeout
  this.responses.forEach(response => {
    if (response.response.status === 'pending') {
      response.response.status = 'timeout';
      response.lastUpdated = new Date();
    }
  });
  
  this.result.finalDecision = 'Network communication timed out';
  return this.save();
};

groupAiNetworkSchema.methods.getPendingAIs = function() {
  return this.responses
    .filter(r => r.response.status === 'pending')
    .map(r => r.aiId);
};

groupAiNetworkSchema.methods.getRespondedAIs = function() {
  return this.responses
    .filter(r => r.response.status === 'responded')
    .map(r => ({ aiId: r.aiId, response: r.response.data }));
};

groupAiNetworkSchema.methods.canComplete = function() {
  const respondedCount = this.responses.filter(r => r.response.status === 'responded').length;
  return respondedCount >= this.context.minimumResponses;
};

// Static methods
groupAiNetworkSchema.statics.findActiveNetworks = function() {
  return this.find({
    status: 'active',
    timeoutAt: { $gt: new Date() }
  });
};

groupAiNetworkSchema.statics.findByGroupId = function(groupId) {
  return this.find({ groupId }).sort({ createdAt: -1 });
};

groupAiNetworkSchema.statics.findByCoordinator = function(coordinatorAiId) {
  return this.find({ coordinatorAiId }).sort({ createdAt: -1 });
};

groupAiNetworkSchema.statics.findExpiredNetworks = function() {
  return this.find({
    status: 'active',
    timeoutAt: { $lt: new Date() }
  });
};

groupAiNetworkSchema.statics.createNetwork = function(groupId, coordinatorAiId, memberAiIds, topic, context, options = {}) {
  const networkData = {
    groupId,
    coordinatorAiId,
    memberAiIds,
    topic,
    context,
    networkType: options.networkType || 'broadcast',
    timeoutAt: options.timeoutAt || new Date(Date.now() + 60 * 60 * 1000),
    settings: { ...this.schema.paths.settings.defaultValue, ...options.settings }
  };
  
  // Initialize responses for all members
  networkData.responses = memberAiIds.map(aiId => ({
    aiId,
    userId: '', // Will be populated when response is added
    response: {
      status: 'pending',
      data: {},
      metadata: {}
    },
    timestamp: new Date(),
    lastUpdated: new Date()
  }));
  
  return this.create(networkData);
};

groupAiNetworkSchema.statics.getNetworkStatistics = function(groupId) {
  return Promise.all([
    this.countDocuments({ groupId, status: 'active' }),
    this.countDocuments({ groupId, status: 'completed' }),
    this.countDocuments({ groupId, status: 'failed' }),
    this.countDocuments({ groupId, status: 'timeout' })
  ]).then(([active, completed, failed, timeout]) => ({
    active,
    completed,
    failed,
    timeout,
    total: active + completed + failed + timeout
  }));
};

// Pre-save middleware
groupAiNetworkSchema.pre('save', function(next) {
  // Auto-timeout expired networks
  if (this.timeoutAt < new Date() && this.status === 'active') {
    this.status = 'timeout';
    this.completedAt = new Date();
  }
  
  // Auto-complete networks that have reached consensus
  if (this.status === 'active' && this.context.requiresConsensus) {
    const consensus = this.calculateConsensus();
    if (consensus.achieved && this.canComplete()) {
      this.status = 'completed';
      this.completedAt = new Date();
    }
  }
  
  next();
});

// Post-save middleware for logging
groupAiNetworkSchema.post('save', function(doc) {
  if (doc.status === 'completed') {
    console.log(`Group AI Network ${doc.networkId} completed with ${doc.result.participationRate * 100}% participation`);
  } else if (doc.status === 'timeout') {
    console.log(`Group AI Network ${doc.networkId} timed out`);
  }
});

module.exports = mongoose.model('GroupAINetwork', groupAiNetworkSchema);
